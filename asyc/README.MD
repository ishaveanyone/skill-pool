试图实现对 异步的控制 实现后台的能够 控制线程的 执行 ，并且 通过前端异步的方式可以实现 实时把处理数据进行返回

## Callable
    1.5 之前 我们运行的实质的 有 runnable 接口中的run方法进行调用 并且进行数据返回的
     
    1.5 之后新增了 Callable 能够 抛出 异常 并且 有 返回值 
##  FutureTask
    其实就是一个runnable，但是又继承了 callable 并且将callable 放在run中执行，并且将结果 一个全局变量 

##  Future
    Future 这个接口封装了 对 执行结果对的获取 以及 对 执行过程的 控制
   
##  Executor
    它将任务的提交与任务的执行分离开来，
    是一个线程管理框架 ，提供了另一种 开启线程的方式
    如果使用new Thread(...).start()的方法处理多线程，有如下缺点：
    
    开销大。对于JVM来说，每次新建线程和销毁线程都会有很大的开销。
    线程缺乏管理。没有一个池来限制线程的数量，如果并发量很高，
    会创建很多的线程，而且线程之间可能会有相互竞争，
    这将会过多得占用系统资源，增加系统资源的消耗量。
    而且线程数量超过系统负荷，容易导致系统不稳定。
    使用线程池的方式，有如下优点：
    
    复用线程。通过复用创建的了的线程，减少了线程的创建、消亡的开销。
    有效控制并发线程数。
    提供了更简单灵活的线程管理。可以提供定时执行、定期执行、单线程、可变线程数等多种线程使用功能。
    
##  ExecutorService
    是功能更加强大的任务执行容器

##  Executors
    是更上一层的容器 可以返回特定的线程池实例
     

    
    
    
    